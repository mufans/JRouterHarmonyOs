"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const schemaParams_1 = require("./schemaParams");
const instrumentVisitor = {
    coverageVariable: {
        description: 'variable to store coverage',
        type: 'string',
        default: '__coverage__',
        nycCommands: schemaParams_1.nycCommands.instrument,
    },
    coverageGlobalScope: {
        description: 'scope to store the coverage variable',
        type: 'string',
        default: 'this',
        nycCommands: schemaParams_1.nycCommands.instrument,
    },
    coverageGlobalScopeFunc: {
        description: 'avoid potentially replaced `Function` when finding global scope',
        type: 'boolean',
        default: true,
        nycCommands: schemaParams_1.nycCommands.instrument,
    },
    ignoreClassMethods: {
        description: 'class method names to ignore for coverage',
        type: 'array',
        items: {
            type: 'string',
        },
        default: [],
        nycCommands: schemaParams_1.nycCommands.instrument,
    },
};
const instrumentParseGen = {
    autoWrap: {
        description: 'allow `return` statements outside of functions',
        type: 'boolean',
        default: true,
        nycCommands: schemaParams_1.nycCommands.instrument,
    },
    esModules: {
        description: 'should files be treated as ES Modules',
        type: 'boolean',
        default: true,
        nycCommands: schemaParams_1.nycCommands.instrument,
    },
    parserPlugins: {
        description: 'babel parser plugins to use when parsing the source',
        type: 'array',
        items: {
            type: 'string',
        },
        /* Babel parser plugins are to be enabled when the feature is stage 3 and
         * implemented in a released version of node.js.
        */
        default: [
            'asyncGenerators',
            'bigInt',
            'dynamicImport',
            'importMeta',
            'topLevelAwait',
            'numericSeparator',
            'objectRestSpread',
            'optionalCatchBinding',
            'classProperties',
            'classPrivateProperties',
            'classPrivateMethods',
        ],
        nycCommands: schemaParams_1.nycCommands.instrument,
    },
    compact: {
        description: 'should the output be compacted?',
        type: 'boolean',
        default: true,
        nycCommands: schemaParams_1.nycCommands.instrument,
    },
    preserveComments: {
        description: 'should comments be preserved in the output?',
        type: 'boolean',
        default: true,
        nycCommands: schemaParams_1.nycCommands.instrument,
    },
    produceSourceMap: {
        description: 'should source maps be produced?',
        type: 'boolean',
        default: true,
        nycCommands: schemaParams_1.nycCommands.instrument,
    },
};
const checkCoverage = {
    excludeAfterRemap: {
        description: 'should exclude logic be performed after the source-map remaps filenames?',
        type: 'boolean',
        default: true,
        nycCommands: schemaParams_1.nycCommands.checkCoverage,
    },
    branches: {
        minimum: 0,
        maximum: 100,
        default: 0,
        description: 'what % of branches must be covered?',
        type: 'number',
        nycCommands: schemaParams_1.nycCommands.checkCoverage,
    },
    functions: {
        minimum: 0,
        maximum: 100,
        default: 0,
        description: 'what % of functions must be covered?',
        type: 'number',
        nycCommands: schemaParams_1.nycCommands.checkCoverage,
    },
    lines: {
        minimum: 0,
        maximum: 100,
        default: 90,
        description: 'what % of lines must be covered?',
        type: 'number',
        nycCommands: schemaParams_1.nycCommands.checkCoverage,
    },
    statements: {
        minimum: 0,
        maximum: 100,
        default: 0,
        description: 'what % of statements must be covered?',
        type: 'number',
        nycCommands: schemaParams_1.nycCommands.checkCoverage,
    },
    perFile: {
        description: 'check thresholds per file',
        type: 'boolean',
        default: false,
        nycCommands: schemaParams_1.nycCommands.checkCoverage,
    },
};
const report = {
    checkCoverage: {
        description: 'check whether coverage is within thresholds provided',
        type: 'boolean',
        default: false,
        nycCommands: schemaParams_1.nycCommands.report,
    },
    reporter: {
        description: 'coverage reporter(s) to use',
        type: 'array',
        items: {
            type: 'string',
        },
        default: ['text'],
        nycCommands: schemaParams_1.nycCommands.report,
        nycAlias: 'r',
    },
    reportDir: {
        description: 'directory to output coverage reports in',
        type: 'string',
        default: 'coverage',
        nycCommands: schemaParams_1.nycCommands.report,
    },
    showProcessTree: {
        description: 'display the tree of spawned processes',
        type: 'boolean',
        default: false,
        nycCommands: schemaParams_1.nycCommands.report,
    },
    skipEmpty: {
        description: 'don\'t show empty files (no lines of code) in report',
        type: 'boolean',
        default: false,
        nycCommands: schemaParams_1.nycCommands.report,
    },
    skipFull: {
        description: 'don\'t show files with 100% statement, branch, and function coverage',
        type: 'boolean',
        default: false,
        nycCommands: schemaParams_1.nycCommands.report,
    },
};
const nycMain = {
    silent: {
        description: 'don\'t output a report after tests finish running',
        type: 'boolean',
        default: false,
        nycCommands: schemaParams_1.nycCommands.main,
        nycAlias: 's',
    },
    all: {
        description: 'whether or not to instrument all files of the project (not just the ones touched by your test suite)',
        type: 'boolean',
        default: false,
        nycCommands: schemaParams_1.nycCommands.main,
        nycAlias: 'a',
    },
    eager: {
        description: 'instantiate the instrumenter at startup (see https://git.io/vMKZ9)',
        type: 'boolean',
        default: false,
        nycCommands: schemaParams_1.nycCommands.main,
    },
    cache: {
        description: 'cache instrumentation results for improved performance',
        type: 'boolean',
        default: true,
        nycCommands: schemaParams_1.nycCommands.main,
        nycAlias: 'c',
    },
    cacheDir: {
        description: 'explicitly set location for instrumentation cache',
        type: 'string',
        nycCommands: schemaParams_1.nycCommands.main,
    },
    babelCache: {
        description: 'cache babel transpilation results for improved performance',
        type: 'boolean',
        default: false,
        nycCommands: schemaParams_1.nycCommands.main,
    },
    useSpawnWrap: {
        description: 'use spawn-wrap instead of setting process.env.NODE_OPTIONS',
        type: 'boolean',
        default: false,
        nycCommands: schemaParams_1.nycCommands.main,
    },
    hookRequire: {
        description: 'should nyc wrap require?',
        type: 'boolean',
        default: true,
        nycCommands: schemaParams_1.nycCommands.main,
    },
    hookRunInContext: {
        description: 'should nyc wrap vm.runInContext?',
        type: 'boolean',
        default: false,
        nycCommands: schemaParams_1.nycCommands.main,
    },
    hookRunInThisContext: {
        description: 'should nyc wrap vm.runInThisContext?',
        type: 'boolean',
        default: false,
        nycCommands: schemaParams_1.nycCommands.main,
    },
    clean: {
        description: 'should the .nyc_output folder be cleaned before executing tests',
        type: 'boolean',
        default: true,
        nycCommands: schemaParams_1.nycCommands.main,
    },
};
const instrumentOnly = {
    inPlace: {
        description: 'should nyc run the instrumentation in place?',
        type: 'boolean',
        default: false,
        nycCommands: schemaParams_1.nycCommands.instrumentOnly,
    },
    exitOnError: {
        description: 'should nyc exit when an instrumentation failure occurs?',
        type: 'boolean',
        default: false,
        nycCommands: schemaParams_1.nycCommands.instrumentOnly,
    },
    delete: {
        description: 'should the output folder be deleted before instrumenting files?',
        type: 'boolean',
        default: false,
        nycCommands: schemaParams_1.nycCommands.instrumentOnly,
    },
    completeCopy: {
        description: 'should nyc copy all files from input to output as well as instrumented files?',
        type: 'boolean',
        default: false,
        nycCommands: schemaParams_1.nycCommands.instrumentOnly,
    },
};
const nyc = {
    description: 'nyc configuration options',
    type: 'object',
    properties: {
        nycrcPath: schemaParams_1.nycrcPath,
        /* Instrumentation settings */
        ...instrumentVisitor,
        /* Instrumentation parser/generator settings */
        ...instrumentParseGen,
        cwd: schemaParams_1.cwd,
        tempDir: schemaParams_1.tempDir,
        /* Test Exclude */
        ...schemaParams_1.testExclude,
        sourceMap: {
            description: 'should nyc detect and handle source maps?',
            type: 'boolean',
            default: true,
            nycCommands: schemaParams_1.nycCommands.instrument,
        },
        require: {
            description: 'a list of additional modules that nyc should attempt to require in its subprocess, e.g., @babel/register, @babel/polyfill',
            type: 'array',
            items: {
                type: 'string',
            },
            default: [],
            nycCommands: schemaParams_1.nycCommands.instrument,
            nycAlias: 'i',
        },
        instrument: {
            description: 'should nyc handle instrumentation?',
            type: 'boolean',
            default: true,
            nycCommands: schemaParams_1.nycCommands.instrument,
        },
        /* Main command options */
        ...nycMain,
        /* Instrument command options */
        ...instrumentOnly,
        /* Check coverage */
        ...checkCoverage,
        /* Report options */
        ...report,
    },
};
const configs = {
    nyc,
    testExclude: {
        type: 'object',
        description: 'test-exclude options',
        properties: {
            ...schemaParams_1.testExclude,
            cwd: schemaParams_1.cwd,
        },
    },
    babelPluginIstanbul: {
        type: 'object',
        description: 'babel-plugin-istanbul options',
        properties: {
            ...schemaParams_1.testExclude,
            ...instrumentVisitor,
            cwd: schemaParams_1.cwd,
        },
    },
    instrumentVisitor: {
        type: 'object',
        description: 'instrument visitor options',
        properties: instrumentVisitor,
    },
    instrumenter: {
        description: 'stand-alone instrumenter options',
        type: 'object',
        properties: {
            ...instrumentVisitor,
            ...instrumentParseGen,
        },
    },
};
const defaultsReducer = (defaults, [name, { default: val }]) => {
    /* Modifying arrays in defaults is safe, does not change schema. */
    if (Array.isArray(val)) {
        val = [...val];
    }
    return {
        ...defaults,
        [name]: val,
    };
};
const schemaObj = {
    ...configs,
    defaults: Object.keys(configs).reduce((defaults, id) => {
        Object.defineProperty(defaults, id, {
            enumerable: true,
            get() {
                /* This defers `process.cwd()` until defaults are requested. */
                return Object.entries(configs[id].properties)
                    .filter(([, info]) => 'default' in info)
                    .reduce((prev, curr) => defaultsReducer(prev, curr), {});
            },
        });
        return defaults;
    }, {}),
};
exports.default = schemaObj;
