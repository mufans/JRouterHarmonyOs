"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRealStackTrace = void 0;
const StackTraceUtil_1 = require("./StackTraceUtil");
const sourceMap = require("source-map");
const path = require("path");
const fs = require("fs");
const instrument_1 = require("../../instrument");
const ohosTestPath = 'src/ohosTest/ets/test';
const ohosRunSourcemapPath = 'build/default/cache/default/default@CompileArkTS/esmodule/debug/sourceMaps.json';
const localRunSourcemapPath = '.test/default/intermediates/assets/default/ets/sourceMaps.map';
const ohosCoverageSourcemapPath = '.test/default/intermediates/ohosTest/coverage_sourcemap/ohosTestSourceMap.map';
const localCoverageSourcemapPath = '.test/default/intermediates/test/coverage_sourcemap/unitTestSourceMap.map';
const runSourceMapRelativePathMap = {
    unitTest: localRunSourcemapPath,
    ohosTest: ohosRunSourcemapPath
};
const coverageSourceMapRelativePathMap = {
    unitTest: localCoverageSourcemapPath,
    ohosTest: ohosCoverageSourcemapPath
};
const getRealStackTrace = async (stackTraceParams) => {
    const testType = stackTraceParams.isLocalTest ? instrument_1.unitTest : instrument_1.ohosTest;
    let stackContent = stackTraceParams.stackContent;
    let isLocalTest = stackTraceParams.isLocalTest;
    let isCoverage = stackTraceParams.isCoverage;
    let modulePath = stackTraceParams.modulePath;
    let hspDependencies = stackTraceParams.hspDependencies;
    let defaultModulePath = modulePath;
    let runSourceMap;
    let coverageSourceMap;
    if (!(0, StackTraceUtil_1.isStackTrace)(stackContent)) {
        return '';
    }
    if (!isLocalTest) {
        return stackContent;
    }
    let stackTrace = (0, StackTraceUtil_1.getStackTrace)(stackContent);
    const line = stackTrace.row;
    if (line == 0) {
        return '';
    }
    let moduleNameFromStackTrace = stackTrace.moduleName;
    let modulePathByModuleName = getModulePathByModuleName(testType, hspDependencies, moduleNameFromStackTrace);
    if (modulePathByModuleName) {
        runSourceMap = getSourceMapByTestType(modulePathByModuleName, runSourceMapRelativePathMap, testType, false);
        coverageSourceMap = getSourceMapByTestType(modulePathByModuleName, coverageSourceMapRelativePathMap, testType, true);
    }
    else {
        runSourceMap = getSourceMapByTestType(defaultModulePath, runSourceMapRelativePathMap, testType, false);
        coverageSourceMap = getSourceMapByTestType(defaultModulePath, coverageSourceMapRelativePathMap, testType, true);
    }
    let filePathFromStackTrace = stackTrace.filePath;
    if (!isLocalTest && isCoverage && filePathFromStackTrace.includes(ohosTestPath)) {
        return stackContent;
    }
    let filePath = filePathFromStackTrace;
    if (isCoverage) {
        let currentFileSourceMap = runSourceMap[filePathFromStackTrace];
        if (currentFileSourceMap) {
            filePath = currentFileSourceMap.sources[0];
            stackTrace.filePath = filePath;
        }
        return parseRowColumn(coverageSourceMap[filePath], stackTrace);
    }
    return parseRowColumn(runSourceMap[filePath], stackTrace);
};
exports.getRealStackTrace = getRealStackTrace;
function getModulePathByModuleName(testType, hspDependencies, hspModuleName) {
    let tmp = hspDependencies;
    if (testType === 'ohosTest') {
        tmp = fromOutputPathToModulePath(hspDependencies);
    }
    let modulePathByModuleName = '';
    tmp.forEach((hspDependency) => {
        let strings = hspDependency.split('\\');
        if (strings[strings.length - 1] === hspModuleName) {
            modulePathByModuleName = hspDependency;
            return;
        }
    });
    return modulePathByModuleName;
}
function fromOutputPathToModulePath(hspDependencies) {
    const length = hspDependencies.length;
    let hspModulePath = new Array(length);
    for (let i = 0; i < length; i++) {
        let hspDependency = hspDependencies[i];
        hspModulePath[i] = hspDependency.substring(0, hspDependency.indexOf('build') - 1);
    }
    return hspModulePath;
}
function getSourceMapByTestType(modulePath, sourceMapRelativePathMap, testType, isCoverage) {
    const sourceMapRelativePath = sourceMapRelativePathMap[testType];
    const sourceMapPath = path.join(modulePath, sourceMapRelativePath);
    if (!fs.existsSync(sourceMapPath)) {
        return '';
    }
    let sourceMapFile = fs.readFileSync(sourceMapPath, 'utf-8');
    if (isCoverage) {
        return JSON.parse('{' + sourceMapFile.substring(0, sourceMapFile.length - 1) + '}');
    }
    return JSON.parse(sourceMapFile);
}
async function parseRowColumn(sourceMapInnerJson, stackTrace) {
    if (!sourceMapInnerJson) {
        return (0, StackTraceUtil_1.getString)(stackTrace);
    }
    const consumer = await new sourceMap.SourceMapConsumer(sourceMapInnerJson);
    const originalPosition = consumer.originalPositionFor({ line: stackTrace.row, column: stackTrace.column });
    let newLine = originalPosition.line;
    let newColumn = originalPosition.column;
    stackTrace.column = newColumn === null ? 0 : newColumn + 1;
    stackTrace.row = newLine === null ? 0 : newLine;
    return (0, StackTraceUtil_1.getString)(stackTrace);
}
