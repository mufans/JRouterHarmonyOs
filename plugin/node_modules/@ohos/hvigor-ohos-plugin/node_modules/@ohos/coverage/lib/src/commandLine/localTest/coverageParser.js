"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseCoverageData = exports.ENGINE_LOG_ERROR_MESSAGE_LOG = void 0;
const path = require("path");
const fs = require("fs");
const generateReportForHvigorw_1 = require("../../generateReportForHvigorw");
const child_process_1 = require("child_process");
const instrument_1 = require("../../instrument");
const SourceMapParser_1 = require("../util/SourceMapParser");
const dataTag = 'OHOS_REPORT_COVERAGE_DATA: ';
const classTag = 'OHOS_REPORT_STATUS: class=';
const statusBaseTag = 'OHOS_REPORT_STATUS: ';
const stackTag = 'OHOS_REPORT_STATUS: stack=';
const streamTag = 'OHOS_REPORT_STATUS: stream=';
const testCaseTag = 'OHOS_REPORT_STATUS: test=';
const statusCodeTag = 'OHOS_REPORT_STATUS_CODE: ';
const resultTag = 'OHOS_REPORT_RESULT: stream=';
const OHOS_REPORT_COVERAGE_PATH = 'OHOS_REPORT_COVERAGE_PATH: ';
exports.ENGINE_LOG_ERROR_MESSAGE_LOG = '[Engine Log]Error message:';
const ENGINE_LOG_TAG = '[Engine Log]';
let className = '';
let testCaseName = '';
let isStackStatus = false;
let statusBaseIndex = -1;
let logFileArr = [];
let engineErrorStart = false;
let isLocalTest = true;
let isCoverage = true;
function dirOperate(coverageData, coverageDirectory, Logger) {
    if (coverageData) {
        if (fs.existsSync(coverageDirectory)) {
            fs.unlinkSync(coverageDirectory);
        }
        fs.writeFileSync(coverageDirectory, coverageData, 'utf8');
        Logger.info('coverage data from call back');
    }
    else {
        Logger.info('coverage data from file');
    }
}
const parseCoverageData = async (coverageParserParam) => {
    const coverageType = coverageParserParam.isLocalTest ? 'test' : 'ohosTest';
    isLocalTest = coverageParserParam.isLocalTest;
    const logPath = `.test/default/intermediates/${coverageType}/coverage_data/coverage.log`;
    const coveragePath = `.test/default/intermediates/${coverageType}/coverage_data/js_coverage.json`;
    const testResultPath = `.test/default/intermediates/${coverageType}/coverage_data/test_result.txt`;
    const Logger = coverageParserParam.logger;
    const modulePath = coverageParserParam.modulePath;
    const projectPath = coverageParserParam.projectPath;
    const logDirectory = path.join(modulePath, logPath);
    const coverageDirectory = path.join(modulePath, coveragePath);
    const testResultDirectory = path.join(modulePath, testResultPath);
    let dependenciesPaths = coverageParserParam.dependenciesPaths;
    isCoverage = coverageParserParam.coverage;
    const hdcPath = coverageParserParam.hdcPath;
    resetStatus();
    let splitSign = '';
    if (process.platform === 'win32') {
        splitSign = '\r\n';
    }
    else if (process.platform === 'darwin' || process.platform === 'linux') {
        splitSign = '\n';
    }
    const logFile = fs.readFileSync(logDirectory, 'utf-8');
    logFileArr = logFile.split(splitSign);
    if (fs.existsSync(testResultDirectory)) {
        fs.unlinkSync(testResultDirectory);
    }
    let coverageData = '';
    for await (const [idx, line] of logFileArr.entries()) {
        if (await isEngineError(line, Logger, dependenciesPaths, modulePath)) {
            continue;
        }
        if (await logStack({ line, logger: Logger, filePath: testResultDirectory, idx, isCoverage, dependenciesPaths, modulePath })
            || logClassAndTestSuite(line, testResultDirectory)
            || logTestResult(line, testResultDirectory)) {
            continue;
        }
        let dataIndex = line.indexOf(dataTag);
        if (dataIndex != -1) {
            let data = line.substring(dataIndex + dataTag.length);
            coverageData = coverageData + data;
            continue;
        }
        if (coverageType === 'ohosTest' && line.indexOf(OHOS_REPORT_COVERAGE_PATH) != -1) {
            coverageData = '';
            let coverageIndex = line.indexOf(OHOS_REPORT_COVERAGE_PATH);
            let pathInDevice = line.substring(coverageIndex + OHOS_REPORT_COVERAGE_PATH.length);
            (0, child_process_1.execSync)(`${hdcPath} file recv ${pathInDevice} ${coverageDirectory}`, { windowsHide: true });
            continue;
        }
    }
    dirOperate(coverageData, coverageDirectory, Logger);
    await generateReport(isCoverage, modulePath, coverageDirectory, projectPath, coverageType, dependenciesPaths);
};
exports.parseCoverageData = parseCoverageData;
async function logStack(logStackParams) {
    const { line, logger, filePath, idx } = logStackParams;
    let tempStatusBaseIndex = line.indexOf(statusBaseTag);
    let hspDependencies = logStackParams.dependenciesPaths;
    let modulePath = logStackParams.modulePath;
    if (tempStatusBaseIndex != -1) {
        isStackStatus = line.substring(tempStatusBaseIndex + statusBaseTag.length).startsWith('stack=');
        statusBaseIndex = tempStatusBaseIndex;
    }
    let stackIndex = line.indexOf(stackTag);
    if (stackIndex != -1) {
        let streamLog = '';
        for (let i = idx; i < logFileArr.length; i++) {
            let streamIndex = logFileArr[i].indexOf(streamTag);
            if (streamIndex !== -1) {
                streamLog = logFileArr[i].substring(streamIndex + streamTag.length);
                break;
            }
        }
        let stackContent = line.substring(stackIndex + stackTag.length);
        let errInfo1 = await (0, SourceMapParser_1.getRealStackTrace)({ hspDependencies, modulePath, stackContent, isLocalTest, isCoverage });
        logger.error(streamLog);
        if (errInfo1 != '') {
            logger.error(errInfo1);
        }
        isStackStatus = true;
        fs.appendFileSync(filePath, streamLog + '\n' + errInfo1 + '\n', 'utf8');
        return true;
    }
    if (isStackStatus) {
        let stackContent = line.substring(statusBaseIndex);
        let errInfo2 = await (0, SourceMapParser_1.getRealStackTrace)({ hspDependencies, modulePath, stackContent, isLocalTest, isCoverage });
        if (errInfo2 != '') {
            logger.error(errInfo2);
        }
        fs.appendFileSync(filePath, errInfo2 + '\n', 'utf8');
        return true;
    }
    return false;
}
async function isEngineError(line, logger, hspDependencies, modulePath) {
    if (line.indexOf(exports.ENGINE_LOG_ERROR_MESSAGE_LOG) > -1) {
        engineErrorStart = true;
    }
    if (engineErrorStart && line.indexOf(ENGINE_LOG_TAG) > -1) {
        let stackContent = line.substring(line.lastIndexOf(ENGINE_LOG_TAG) + ENGINE_LOG_TAG.length);
        let errInfo = await (0, SourceMapParser_1.getRealStackTrace)({ hspDependencies, modulePath, stackContent, isLocalTest: true, isCoverage: false });
        logger.error(errInfo);
        return true;
    }
    if (engineErrorStart && line.indexOf(ENGINE_LOG_TAG) < 0) {
        engineErrorStart = false;
    }
    return false;
}
function logClassAndTestSuite(line, filePath) {
    let classIndex = line.indexOf(classTag);
    if (classIndex != -1) {
        let tempClassName = line.substring(classIndex + classTag.length);
        if (tempClassName != className) {
            className = tempClassName;
            fs.appendFileSync(filePath, `class=${className}\n`, 'utf8');
        }
        return true;
    }
    let testCaseIndex = line.indexOf(testCaseTag);
    if (testCaseIndex != -1) {
        let tempTestCaseName = line.substring(testCaseIndex + testCaseTag.length);
        if (tempTestCaseName != testCaseName) {
            testCaseName = tempTestCaseName;
            fs.appendFileSync(filePath, `test=${testCaseName}\n`, 'utf8');
        }
        return true;
    }
    return false;
}
function logTestResult(line, filePath) {
    let resultIndex = line.indexOf(resultTag);
    if (resultIndex != -1) {
        let resultContent = line.substring(resultIndex + resultTag.length);
        fs.appendFileSync(filePath, resultContent + '\n', 'utf8');
        return true;
    }
    let statusCodeIndex = line.indexOf(statusCodeTag);
    if (statusCodeIndex != -1) {
        let statusCode = Number.parseInt(line.substring(statusCodeIndex + statusCodeTag.length));
        switch (statusCode) {
            case 0:
                fs.appendFileSync(filePath, 'result=Success\n', 'utf8');
                break;
            case -1:
                fs.appendFileSync(filePath, 'result=Error\n', 'utf8');
                break;
            case -2:
                fs.appendFileSync(filePath, 'result=Failure\n', 'utf8');
                break;
            case -3:
                fs.appendFileSync(filePath, 'result=Ignore\n', 'utf8');
                break;
        }
        return true;
    }
    return false;
}
function resetStatus() {
    className = '';
    testCaseName = '';
    isStackStatus = false;
    statusBaseIndex = -1;
}
async function generateReport(isCoverage, modulePath, coverageDirectory, projectPath, coverageType, dependenciesPaths) {
    if (!isCoverage) {
        return;
    }
    let initCoveragePath = `${modulePath}/.test/default/intermediates/${coverageType}/init_coverage.json`;
    let jsCoveragePath = `${modulePath}/.test/default/intermediates/${coverageType}/coverage_data/js_coverage.json`;
    if (!fs.existsSync(initCoveragePath)) {
        return;
    }
    for (let item of dependenciesPaths) {
        let hspModule = item.split('build\\default\\outputs')[0];
        if (hspModule == item) {
            hspModule = item.split('build/default/outputs')[0];
        }
        let hspInitCoveragePath;
        let hspJsCoveragePath;
        if (coverageType.includes(instrument_1.ohosTest)) {
            hspInitCoveragePath = path.join(hspModule, instrument_1.ohosTestInitPath);
            hspJsCoveragePath = '';
        }
        else {
            hspInitCoveragePath = path.join(hspModule, instrument_1.unitTestInitPath);
            hspJsCoveragePath = path.join(hspModule, instrument_1.localTestCoveragePath);
        }
        if (fs.existsSync(hspInitCoveragePath)) {
            initCoveragePath = initCoveragePath + '#' + hspInitCoveragePath;
        }
        if (fs.existsSync(hspJsCoveragePath)) {
            jsCoveragePath = jsCoveragePath + '#' + hspJsCoveragePath;
        }
    }
    const reportPath = `${modulePath}/.test/default/outputs/${coverageType}/reports`;
    let coverPath = fs.existsSync(coverageDirectory) ? `${jsCoveragePath}#${initCoveragePath}` : initCoveragePath;
    await (0, generateReportForHvigorw_1.generateReportForHvigorw)(projectPath, reportPath, coverPath);
}
